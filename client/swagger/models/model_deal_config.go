// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"fmt"
	"net/url"
	"regexp"
	"strings"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
)

// ModelDealConfig model deal config
//
// swagger:model model.DealConfig
type ModelDealConfig struct {

	// AutoCreateDeals enables automatic deal creation after preparation completes
	AutoCreateDeals bool `json:"autoCreateDeals,omitempty"`

	// DealAnnounceToIpni indicates whether to announce deals to the IPNI (InterPlanetary Network Indexer)
	DealAnnounceToIpni bool `json:"dealAnnounceToIpni,omitempty"`

	// DealDuration specifies the deal duration in epochs (must be between 2880 and 1555200)
	// Minimum: 2880 epochs (~24 hours), Maximum: 1555200 epochs (~540 days)
	DealDuration int64 `json:"dealDuration,omitempty"`

	// DealHTTPHeaders contains HTTP headers for deal requests
	// Expected format: map[string]string with valid HTTP header keys and values
	DealHTTPHeaders interface{} `json:"dealHttpHeaders,omitempty"`

	// DealKeepUnsealed indicates whether to keep unsealed copy of the data
	DealKeepUnsealed bool `json:"dealKeepUnsealed,omitempty"`

	// DealPricePerDeal specifies the price in FIL per deal (must be non-negative)
	DealPricePerDeal float64 `json:"dealPricePerDeal,omitempty"`

	// DealPricePerGb specifies the price in FIL per GiB (must be non-negative)
	DealPricePerGb float64 `json:"dealPricePerGb,omitempty"`

	// DealPricePerGbEpoch specifies the price in FIL per GiB per epoch (must be non-negative)
	DealPricePerGbEpoch float64 `json:"dealPricePerGbEpoch,omitempty"`

	// DealProvider specifies the Storage Provider ID for deals
	// Must be a valid Filecoin actor ID (e.g., f01234 or t01234)
	DealProvider string `json:"dealProvider,omitempty"`

	// DealStartDelay specifies the deal start delay in epochs (must be between 0 and 141120)
	// Minimum: 0 epochs (immediate), Maximum: 141120 epochs (~49 days)
	DealStartDelay int64 `json:"dealStartDelay,omitempty"`

	// DealTemplate specifies the deal template name or ID to use (optional)
	DealTemplate string `json:"dealTemplate,omitempty"`

	// DealURLTemplate specifies the URL template for retrieving deal data
	// Must be a valid URL template with optional placeholders
	DealURLTemplate string `json:"dealUrlTemplate,omitempty"`

	// DealVerified indicates whether deals should be verified deals
	DealVerified bool `json:"dealVerified,omitempty"`
}

// Validate validates this model deal config
func (m *ModelDealConfig) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateDealDuration(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDealStartDelay(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePrices(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDealProvider(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDealHTTPHeaders(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDealURLTemplate(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ModelDealConfig) validateDealDuration(formats strfmt.Registry) error {
	if m.DealDuration == 0 {
		return nil // Optional field
	}

	if m.DealDuration < 2880 || m.DealDuration > 1555200 {
		return errors.New(400, fmt.Sprintf("deal duration must be between 2880 and 1555200 epochs, got %d", m.DealDuration))
	}

	return nil
}

func (m *ModelDealConfig) validateDealStartDelay(formats strfmt.Registry) error {
	if m.DealStartDelay < 0 || m.DealStartDelay > 141120 {
		return errors.New(400, fmt.Sprintf("deal start delay must be between 0 and 141120 epochs, got %d", m.DealStartDelay))
	}

	return nil
}

func (m *ModelDealConfig) validatePrices(formats strfmt.Registry) error {
	if m.DealPricePerDeal < 0 {
		return errors.New(400, fmt.Sprintf("deal price per deal must be non-negative, got %f", m.DealPricePerDeal))
	}

	if m.DealPricePerGb < 0 {
		return errors.New(400, fmt.Sprintf("deal price per GiB must be non-negative, got %f", m.DealPricePerGb))
	}

	if m.DealPricePerGbEpoch < 0 {
		return errors.New(400, fmt.Sprintf("deal price per GiB per epoch must be non-negative, got %f", m.DealPricePerGbEpoch))
	}

	return nil
}

func (m *ModelDealConfig) validateDealProvider(formats strfmt.Registry) error {
	if m.DealProvider == "" {
		return nil // Optional field
	}

	if !isValidDealProviderID(m.DealProvider) {
		return errors.New(400, fmt.Sprintf("invalid storage provider ID format: %s (must be f01234 or t01234 format)", m.DealProvider))
	}

	return nil
}

func (m *ModelDealConfig) validateDealHTTPHeaders(formats strfmt.Registry) error {
	if m.DealHTTPHeaders == nil {
		return nil // Optional field
	}

	headers, ok := m.DealHTTPHeaders.(map[string]interface{})
	if !ok {
		return errors.New(400, "HTTP headers must be a map[string]string")
	}

	for key, value := range headers {
		if !isValidDealHTTPHeaderKey(key) {
			return errors.New(400, fmt.Sprintf("invalid HTTP header key: %s", key))
		}

		strValue, ok := value.(string)
		if !ok {
			return errors.New(400, fmt.Sprintf("HTTP header value must be a string for key: %s", key))
		}

		// Check for control characters in header value
		for _, r := range strValue {
			if r < 32 || r == 127 {
				return errors.New(400, fmt.Sprintf("HTTP header value contains invalid control characters for key: %s", key))
			}
		}
	}

	return nil
}

func (m *ModelDealConfig) validateDealURLTemplate(formats strfmt.Registry) error {
	if m.DealURLTemplate == "" {
		return nil // Optional field
	}

	if !isValidDealURLTemplate(m.DealURLTemplate) {
		return errors.New(400, fmt.Sprintf("invalid URL template: %s", m.DealURLTemplate))
	}

	return nil
}

// ContextValidate validates this model deal config based on context it is used
func (m *ModelDealConfig) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *ModelDealConfig) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ModelDealConfig) UnmarshalBinary(b []byte) error {
	var res ModelDealConfig
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// Helper functions for deal config validation

// isValidDealProviderID validates Filecoin actor ID format (f01234 or t01234)
func isValidDealProviderID(id string) bool {
	if len(id) < 2 {
		return false
	}

	// Check prefix
	if id[0] != 'f' && id[0] != 't' {
		return false
	}

	// Check if it starts with f0 or t0
	if len(id) < 3 || id[1] != '0' {
		return false
	}

	// Check remaining characters are digits
	for i := 2; i < len(id); i++ {
		if id[i] < '0' || id[i] > '9' {
			return false
		}
	}

	// Must have at least one digit after f0/t0
	return len(id) > 2
}

// isValidDealHTTPHeaderKey validates HTTP header key format
func isValidDealHTTPHeaderKey(key string) bool {
	if key == "" {
		return false
	}

	// HTTP header field names consist of printable US-ASCII characters
	// excluding separators
	separators := "()<>@,;:\\\"/[]?={} \t"

	for _, r := range key {
		// Must be printable ASCII (33-126)
		if r < 33 || r > 126 {
			return false
		}

		// Must not be a separator
		if strings.ContainsRune(separators, r) {
			return false
		}
	}

	return true
}

// isValidDealURLTemplate validates URL template format
func isValidDealURLTemplate(template string) bool {
	if template == "" {
		return false
	}

	// Replace template placeholders with dummy values for validation
	// Common placeholders: {piece_cid}, {data_cid}, {path}, etc.
	placeholderRegex := regexp.MustCompile(`\{[^}]+\}`)
	processedURL := placeholderRegex.ReplaceAllString(template, "placeholder")

	// Try to parse as URL
	u, err := url.Parse(processedURL)
	if err != nil {
		return false
	}

	// Must have a scheme (http or https)
	if u.Scheme != "http" && u.Scheme != "https" {
		return false
	}

	// Must have a host
	if u.Host == "" {
		return false
	}

	return true
}
